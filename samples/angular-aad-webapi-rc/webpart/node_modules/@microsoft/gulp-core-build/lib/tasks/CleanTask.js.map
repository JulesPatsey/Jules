{"version":3,"sources":["tasks/CleanTask.ts"],"names":[],"mappings":";;;;;;AAAA,yBAAyB,YAAY,CAAC,CAAA;AAMtC;IAA+B,6BAAsB;IAArD;QAA+B,8BAAsB;QAC5C,SAAI,GAAW,OAAO,CAAC;QAEvB,eAAU,GAAiB,EACjC,CAAC;IA+CJ,CAAC;IA7CQ,+BAAW,GAAlB,UACE,IAAe,EACf,gBAA2C;QAE3C,4BAA4B;QAC5B,IAAM,GAAG,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;QAC3B,4BAA4B;QAE5B,IAAA,qBAA4E,EAApE,0BAAU,EAAE,wBAAS,EAAE,8BAAY,EAAE,0BAAU,CAAsB;QAC7E,IAAI,UAAU,GAAG;YACf,UAAU;YACV,YAAY;YACZ,SAAS;YACT,UAAU;SACX,CAAC;QAEF,yEAAyE;QACzE,GAAG,CAAC,CAAqB,UAA4B,EAA5B,KAAA,IAAI,CAAC,WAAW,CAAC,WAAW,EAA5B,cAA4B,EAA5B,IAA4B,CAAC;YAAjD,IAAM,UAAU,SAAA;YACnB,EAAE,CAAC,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC;gBAC7B,6DAA6D;gBAC7D,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YAC7E,CAAC;SACF;QAED,IAAI,WAAW,GAA8B,EAAE,CAAC;QAEhD,uEAAuE;QACvE,UAAU,CAAC,OAAO,CAAC,UAAA,IAAI;YACrB,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACX,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;YAC3B,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,mDAAmD;QACnD,UAAU,GAAG,EAAE,CAAC;QAChB,GAAG,CAAC,CAAC,IAAI,IAAI,IAAI,WAAW,CAAC,CAAC,CAAC;YAC7B,EAAE,CAAC,CAAC,WAAW,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACxB,CAAC;QACH,CAAC;QAED,GAAG,CAAC,UAAU,CAAC;aACZ,IAAI,CAAC,cAAM,OAAA,gBAAgB,EAAE,EAAlB,CAAkB,CAAC;aAC9B,KAAK,CAAC,UAAC,KAAK,IAAK,OAAA,gBAAgB,CAAC,KAAK,CAAC,EAAvB,CAAuB,CAAC,CAAC;IAC/C,CAAC;IACH,gBAAC;AAAD,CAnDA,AAmDC,CAnD8B,mBAAQ,GAmDtC;AAnDY,iBAAS,YAmDrB,CAAA","file":"tasks/CleanTask.js","sourcesContent":["import { GulpTask } from './GulpTask';\r\nimport gulp = require('gulp');\r\n\r\nexport interface ICleanConfig {\r\n}\r\n\r\nexport class CleanTask extends GulpTask<ICleanConfig> {\r\n  public name: string = 'clean';\r\n\r\n  public taskConfig: ICleanConfig = {\r\n  };\r\n\r\n  public executeTask(\r\n    gulp: gulp.Gulp,\r\n    completeCallback: (result?: Object) => void\r\n  ): void {\r\n    /* tslint:disable:typedef */\r\n    const del = require('del');\r\n    /* tslint:disable:typedef */\r\n\r\n    const { distFolder, libFolder, libAMDFolder, tempFolder } = this.buildConfig;\r\n    let cleanPaths = [\r\n      distFolder,\r\n      libAMDFolder,\r\n      libFolder,\r\n      tempFolder\r\n    ];\r\n\r\n    // Give each registered task an opportunity to add their own clean paths.\r\n    for (const executable of this.buildConfig.uniqueTasks) {\r\n      if (executable.getCleanMatch) {\r\n        // Set the build config, as tasks need this to build up paths\r\n        cleanPaths = cleanPaths.concat(executable.getCleanMatch(this.buildConfig));\r\n      }\r\n    }\r\n\r\n    let uniquePaths: { [key: string]: string } = {};\r\n\r\n    // Create dictionary of unique paths. (Could be replaced with ES6 set.)\r\n    cleanPaths.forEach(path => {\r\n      if (!!path) {\r\n        uniquePaths[path] = path;\r\n      }\r\n    });\r\n\r\n    // Reset cleanPaths to only unique non-empty paths.\r\n    cleanPaths = [];\r\n    for (let path in uniquePaths) {\r\n      if (uniquePaths.hasOwnProperty(path)) {\r\n        cleanPaths.push(path);\r\n      }\r\n    }\r\n\r\n    del(cleanPaths)\r\n      .then(() => completeCallback())\r\n      .catch((error) => completeCallback(error));\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\src"}