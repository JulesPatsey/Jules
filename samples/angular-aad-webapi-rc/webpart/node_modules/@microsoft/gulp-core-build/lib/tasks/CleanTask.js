"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var GulpTask_1 = require('./GulpTask');
var CleanTask = (function (_super) {
    __extends(CleanTask, _super);
    function CleanTask() {
        _super.apply(this, arguments);
        this.name = 'clean';
        this.taskConfig = {};
    }
    CleanTask.prototype.executeTask = function (gulp, completeCallback) {
        /* tslint:disable:typedef */
        var del = require('del');
        /* tslint:disable:typedef */
        var _a = this.buildConfig, distFolder = _a.distFolder, libFolder = _a.libFolder, libAMDFolder = _a.libAMDFolder, tempFolder = _a.tempFolder;
        var cleanPaths = [
            distFolder,
            libAMDFolder,
            libFolder,
            tempFolder
        ];
        // Give each registered task an opportunity to add their own clean paths.
        for (var _i = 0, _b = this.buildConfig.uniqueTasks; _i < _b.length; _i++) {
            var executable = _b[_i];
            if (executable.getCleanMatch) {
                // Set the build config, as tasks need this to build up paths
                cleanPaths = cleanPaths.concat(executable.getCleanMatch(this.buildConfig));
            }
        }
        var uniquePaths = {};
        // Create dictionary of unique paths. (Could be replaced with ES6 set.)
        cleanPaths.forEach(function (path) {
            if (!!path) {
                uniquePaths[path] = path;
            }
        });
        // Reset cleanPaths to only unique non-empty paths.
        cleanPaths = [];
        for (var path in uniquePaths) {
            if (uniquePaths.hasOwnProperty(path)) {
                cleanPaths.push(path);
            }
        }
        del(cleanPaths)
            .then(function () { return completeCallback(); })
            .catch(function (error) { return completeCallback(error); });
    };
    return CleanTask;
}(GulpTask_1.GulpTask));
exports.CleanTask = CleanTask;

//# sourceMappingURL=CleanTask.js.map
