"use strict";
var fs = require('fs');
var os = require('os');
var path = require('path');
var yargs = require('yargs');
var coreBuild = require('@microsoft/gulp-core-build');
var SchemaValidator_1 = require('./jsonUtilities/SchemaValidator');
var BuildRigConstants_1 = require('./BuildRigConstants');
// Helper function to lock the paths to schema files
function getSchemaFilePath(filename) {
    return path.join(__dirname, 'schemas', filename);
}
/**
 * Represents a gulp-core-build build "rig", or a collection of tasks and
 * configurations. It can be extended to define more top-level configurable tasks,
 * inject subtasks into the chain, register arguments to the command line.
 *
 * This class represents all the logic which doesn't belong in a rig, and should instead
 * be a part of gulp-core-build. Thus, this class should be removed once that logic
 * is properly replicated in gulp-core-build.
 *
 * @todo 178074, 253519, 253526
 */
var BuildRig = (function () {
    function BuildRig() {
    }
    /**
     * The primary entry point into this build rig, accepts a gulp instance which is passed through to gulp-core-build
     */
    BuildRig.prototype.initialize = function (gulp) {
        // Initialize yargs & figure out which command we are running
        var yargsArgs = this.getYargs();
        var command = yargsArgs.argv._[0];
        this.args = yargsArgs.argv;
        // Collect the tasks which need to be registered
        var tasks = this.getTasks();
        // Reset the args and reconfigure based on the selected command
        yargsArgs.reset();
        if (tasks.has(command)) {
            var task = tasks.get(command);
            if (task.arguments) {
                task.arguments(yargsArgs);
            }
        }
        // Note this overrides the getters for ship and production on args
        // @todo 264931 - the production flag should be removed
        this.args.ship = this.args.production = (this.args.production || this.args.ship);
        // Since gulp-core-build doesn't recognize the --ship flag, ensure it gets the right state
        coreBuild.mergeConfig({
            production: this.args.ship,
            shouldWarningsFailBuild: this.args.ship
        });
        // Register all the tasks with gulp-core-build
        tasks.forEach(function (definition, name) {
            coreBuild.task(name, definition.executable);
        });
        // If they are just looking for the task list, save time by not reading config files
        if (!this.args.tasks) {
            // Configure tasks for a normal build
            console.log('Build target: ' + (this.args.ship ?
                BuildRigConstants_1.BuildRigConstants.flavors.ship.toUpperCase() :
                BuildRigConstants_1.BuildRigConstants.flavors.debug.toUpperCase()));
            this.setupSharedConfig();
            try {
                this._loadCustomConfigs();
            }
            catch (error) {
                console.log(error);
                throw error;
            }
            this.finalizeSharedConfig();
        }
        coreBuild.initialize(gulp);
    };
    /**
     * Override this function to register more .json files which can be read, validated, and passed through
     * to a callback function. See IConfigurableTask for more information.
     * @todo 253526 push this code into gulp-core-build/the individual task definitions
     */
    BuildRig.prototype.getCustomConfigs = function () {
        return [
            {
                callback: function (props) {
                    coreBuild.mergeConfig({ properties: props });
                },
                configFile: 'config.json',
                schemaFile: getSchemaFilePath('config.schema.json')
            }
        ];
    };
    ;
    /**
     * Override this function to register more top-level command line arguments (i.e. not task-specific).
     * Ideally, extend the ICoreBuildArgs when hooking into this function
     * @todo 253519 : this code should be removed once we determine the interface for argument parsing with GCB
     */
    BuildRig.prototype.getYargs = function () {
        var yargsArgs = yargs.usage()
            .option('production', {
            alias: 'p',
            describe: 'build in ship mode with full localization and minimization',
            boolean: true
        })
            .option('ship', {
            alias: 'p',
            describe: 'build in ship mode with full localization and minimization',
            boolean: true
        })
            .option('verbose', {
            describe: 'run the build with verbose logging'
        })
            .option('tasks', {
            alias: ['T', 'tasks-simple'],
            describe: 'shows the list of tasks which can be run'
        })
            .help('h')
            .global(['production', 'verbose', 'h'])
            .usage([
            'CONFIG FILES'
        ].concat(this.getCustomConfigs().map(function (config) {
            return "   " + config.configFile + os.EOL + (config.readmeUrl ? config.readmeUrl : '') + os.EOL;
        }))
            .join(os.EOL));
        return yargsArgs;
    };
    /**
     * Loads all custom configuration files from disk and applies them to the task configuration callback
     * @todo VSO #253526 - move this into each task, respectively
     */
    BuildRig.prototype._loadCustomConfigs = function () {
        for (var _i = 0, _a = this.getCustomConfigs(); _i < _a.length; _i++) {
            var taskConfigInfo = _a[_i];
            var configFilename = path.join(process.cwd(), 'config', taskConfigInfo.configFile);
            var schemaFilename = taskConfigInfo.schemaFile;
            var rawConfig = this._readConfigFile(configFilename, schemaFilename, taskConfigInfo.readmeUrl);
            if (rawConfig) {
                taskConfigInfo.callback(rawConfig);
            }
        }
    };
    /**
     * Helper function which loads a custom config file from disk, runs the SchemaValidator on it,
     * and then apply it to the callback defined on the IConfigurableTask
     */
    BuildRig.prototype._readConfigFile = function (filename, schemafile, helpUrl) {
        if (!fs.existsSync(filename)) {
            return undefined;
        }
        else {
            if (this.args.verbose) {
                console.log("Found config file: " + path.basename(filename));
            }
            var data = void 0;
            try {
                if (fs.existsSync(schemafile)) {
                    if (this.args.verbose) {
                        console.log("Schema file " + schemafile + " not found");
                    }
                    data = SchemaValidator_1.SchemaValidator.readAndValidateJson(filename, schemafile);
                }
                else {
                    data = SchemaValidator_1.SchemaValidator.readCommentedJsonFile(filename);
                }
            }
            catch (error) {
                throw error.toString() +
                    (helpUrl ? 'For more usage, please read:' + os.EOL + helpUrl : '');
            }
            return data;
        }
    };
    return BuildRig;
}());
exports.BuildRig = BuildRig;

//# sourceMappingURL=BuildRig.js.map
