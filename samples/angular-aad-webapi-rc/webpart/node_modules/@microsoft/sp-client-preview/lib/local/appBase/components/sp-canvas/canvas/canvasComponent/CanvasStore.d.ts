import { _QosMonitor } from '@ms/sp-telemetry';
import { DisplayMode, ServiceScope } from '@microsoft/sp-core-library';
import { ClientSideWebPartManager } from '@microsoft/sp-webpart-base';
import { CanvasA11yManager } from '../../a11y/CanvasA11y';
import ICanvasControl, { CanvasControlComponent } from '../canvasControl/ICanvasControl';
import CanvasLayout from '../canvasLayout/CanvasLayout';
import { IControlPosition } from '../canvasLayout/ICanvasLayout';
import { IToolboxProps } from '../../toolbox/toolbox/IToolbox';
export default class CanvasStore {
    private _a11yManager;
    private _canvasElement;
    private _controlComponentMap;
    private _controlsProps;
    private _canvasLayout;
    private _displayMode;
    private _fetchedWebParts;
    private _handleCanvasChanged;
    private _isDeleteDialogOpen;
    private _oldActiveElement;
    private _pollId;
    private _render;
    private _scrollableParentElement;
    private _scrollThreshold;
    private _selectedControlId;
    private _hoveredControlId;
    private _deletedRow;
    private _rowToBeDeleted;
    private _toolboxProps;
    private _webPartManager;
    private static readonly _isCanvasJsonFlightEnabled;
    static readonly isLayoutSupported: boolean;
    constructor(serviceScope: ServiceScope, render: () => void, mode: DisplayMode, serializedCanvas?: string, handleCanvasChanged?: () => void, scrollThreshold?: number);
    readonly addReference: (ref: CanvasControlComponent) => void;
    a11yManager: CanvasA11yManager;
    canvasElement: HTMLElement;
    readonly controlsProps: ICanvasControl[];
    readonly canvasLayout: CanvasLayout;
    deletedRow: number;
    deletedControlLayout: IControlPosition;
    displayMode: DisplayMode;
    readonly isDeleteDialogOpen: boolean;
    readonly notifyChanged: () => void;
    scrollableParent: HTMLElement;
    readonly scrollThreshold: number;
    /**
     * The hoveredControlId keeps track of which control the pointer is currently over.
     * It is used as a workaround to track pointer events on web parts that have IFrames.
     */
    hoveredControlId: string;
    selectedControlId: string;
    readonly toolboxProps: IToolboxProps;
    readonly webPartManager: ClientSideWebPartManager;
    handleToolboxItemClick(position: number | IControlPosition, itemProps: ICanvasControl): void;
    deleteControl(row: number, layout: IControlPosition): void;
    getControl(id: string): CanvasControlComponent;
    openToolbox(position: number | IControlPosition, verticalPosition: number, horizontalPosition?: number): void;
    closeToolbox(): void;
    createQosScope(scope: string): _QosMonitor;
    handleConfigureButtonClicked(id: string): void;
    handleDeleteButtonClicked(row: number, layout: IControlPosition): void;
    handleDeleteDialogConfirmation(): void;
    handleDeleteDialogDismiss(): void;
    /**
     * IFrame's swallow pointer events, so this is a workaround to detect when focus has shifted to
     * an IFrame. Additionally, to compensate for IFrame to IFrame interactions we poll for the document.activeElement.
     * If document.activeElement is not the same as it was in the last poll then the focus has shifted from the IFrame.
     * If the new document.activeElement is an IFrame continue polling, otherwise we can stop polling because focus
     * is back inside of the current document.
     */
    handleWindowBlur(e: MouseEvent): void;
    deserialize(serializedCanvas: string): void;
    reclaimFocus(): void;
    /**
     * If needed, scrolls element into view after the element is added to the Canvas.
     * Note: Javascript scrollIntoView is not consistent cross-browser
     *
     * @param type - Specifies whether to scroll if the 'full' web part is visible or a 'partial' part of the web part
     *   is visible
     * @param element - A rendered element inside the Canvas to scroll to
     * @param duration - The length of time the animation should take. Frames are calculated by duration / delta time.
     * @param margin - Optional. Margin to be scrolled into view. If not provided, margin is not scrolled into view
     */
    scrollIntoView(type: 'full' | 'partial', element: HTMLElement, duration: number, margin?: number): void;
    serialize(): string;
    tryGeneratePreviewImageUrl(): string;
    private _getControlComponentById(id);
    private _setControlComponentById(id, component);
    private readonly _canvasControls;
    private _selectedControlIdInternal;
    private _positionCandidateForDeletion;
    private _serializeAsHtml();
    /**
     * Iterates over the current canvas controls and serializes the control data
     * Note: We encodeURI the content and send it to the server. ContentSerializer.ToHtml
     * decodes this using HtmlUtility.Decode before transforming to Html
     */
    private _serializeAsJson();
    /**
     * Processes the Json object string generated by the ContentSerializer.ToJson
     * server API and constructs canvas control objects. No decodeURI required since
     * API doesn't encode content
     */
    private _processCanvasContent(serializedCanvas);
    private _addControlToCanvas(position, control);
    private _addReference(ref);
    /**
     * Calculates the easing number using the quadratic in-out formula
     */
    private _calculateEasing(time, start, diff, duration);
    /**
     * If the Canvas is in DisplayMode.Edit then fetch the web part manifests in the background.
     */
    private _fetchWebParts();
    private _fillToolboxItems();
    private _extractWebPartData(manifest, entry);
    private _getManifestMap();
    private _pollActiveElement();
    private _scroll(start, end, duration, time?);
    private _scrollElementIntoView(frameBottom, element, duration, margin);
    private _notifyChanged();
    private _handleMonitoredException(qos, err, props?);
}
