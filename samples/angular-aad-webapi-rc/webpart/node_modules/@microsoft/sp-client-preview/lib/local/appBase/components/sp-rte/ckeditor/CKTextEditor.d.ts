/// <reference types="es6-promise" />
import { _LogSource } from '@ms/sp-telemetry';
import { IBounds } from '../rte/IBounds';
import { IRange } from '../rte/IRange';
import { IRichTextFormat } from '../rte/IRichTextFormat';
import { IRichTextEditor } from '../rte/IRichTextEditor';
import { IRichTextEditorLoader } from '../rte/IRichTextEditorLoader';
import { IRichTextEditorConfiguration } from '../rte/IRichTextEditorConfiguration';
import './CKTextEditor.scss';
/**
 * Implementation of IRichTextEditor for CKEditor @4.5.11
 */
export default class CKTextEditor implements IRichTextEditor {
    static moduleLoader: IRichTextEditorLoader;
    protected static logSource: _LogSource;
    protected _editor: CKEDITOR.editor;
    protected _editorElement: HTMLDivElement;
    protected _handleTextChange: () => void;
    protected _startupFocus: boolean;
    private _config;
    private _handleSelectionChange;
    private _lastSelectedRanges;
    private _onReadyCallback;
    private _blockStyles;
    /**
     * Preload ck editor
     */
    static preloadEditor(config: IRichTextEditorConfiguration): void;
    /**
     * @return Promise of the instance that resolves once the editor is loaded on the element
     *
     * Static wrapper for constructing an instance
     */
    static createNewEditor(config: IRichTextEditorConfiguration, currentHTML: string, editorElement: HTMLDivElement, selectionChangeCallback: (range: IRange, forceUpdate?: boolean) => void, textChangeCallback: () => void, startupFocus?: boolean): Promise<CKTextEditor>;
    private static _getSelectedLink(editor);
    private static readonly _IS_CKEDITOR_TABLEPASTE_FLIGHTED;
    /**
     * Use createNewEditor instead of constructor to ensure using the editor after it's loaded
     * Note: TypeScript doesn't allow private constructors
     */
    constructor(config: IRichTextEditorConfiguration, currentHTML: string, editorElement: HTMLDivElement, selectionChangeCallback: (range: IRange, forceUpdate?: boolean) => void, textChangeCallback: () => void, startUpFocus?: boolean, onReadyCallback?: () => void);
    protected _initialize(currentHTML: string): void;
    protected _addCustomToolbarCommands(): void;
    clearFormatting(start: number, end: number): void;
    destroy(): string;
    focus(): void;
    /**
     * @param start - Start position of selection
     * @param end - End position of selection
     * @param formats - Map of key:value pairs for formats to apply
     * @param applyAllFormatsToLine - Forces all formats to be applied to the whole line(s). If not provided,
     * formats are divided into two buckets (line vs non-line) based on their isLine field
     *
     * A unified method for applying formats to any selection
     */
    format(start: number, end: number, formats: Object, applyAllFormatsToLine?: boolean): void;
    getBounds(position: number): IBounds;
    getFormatValue(start: number, end: number, format: IRichTextFormat): boolean | string;
    getSelection(): IRange;
    getText(range?: IRange): string;
    getHTML(): string;
    getEditorType(): string;
    /**
     * @param format - Name of the format to apply from SPRTE_FORMATS
     * @param start - Start value of range
     * @param end - End value of range
     *
     * @return A dictionary of string=>boolean indicating if the format is applied to the given range
     */
    isFormatAppliedToRange(start: number, end: number, format: IRichTextFormat): boolean;
    onReady(callback: () => void): void;
    setSelection(range: IRange): void;
    protected _handleSelectionChangeConvert(evt?: CKEDITOR.eventInfo): void;
    private _isHeadingActive(tagName, path?);
    private _getHeadingCommandDefinition(tagName);
    private _fakeSelectionChange();
    private _handlePluginsLoaded(evt);
    private _handleInstanceReady();
    private _handlePaste(evt);
}
