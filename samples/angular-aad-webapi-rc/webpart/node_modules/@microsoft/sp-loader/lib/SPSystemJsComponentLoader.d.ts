/// <reference types="es6-promise" />
import { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import { ISPComponentLoader, ILoadScriptOptions, IApplicationPreloadedData } from './ISPComponentLoader';
/**
 * The global component loader for SP client-side applications and webparts.
 *
 * @alpha
 */
export default class SPSystemJsComponentLoader implements ISPComponentLoader {
    /**
     * @internal
     */
    static _currentLocale: string;
    private static _headElement;
    private static _loadComponentLogSource;
    private _systemJsLoader;
    /**
     * @internal
     */
    constructor();
    /**
     * This is called by the page scripts to start loading the framework. Do not call it from your own code.
     */
    start<TApplication>(preloadedData: IApplicationPreloadedData): Promise<TApplication>;
    /**
     * Given a URL, load a script.
     *
     * @param url     - The script URL.
     * @param options - globalExportsName: If the script isn't an AMD module and loads a global member on the page,
     *                    specify the global member's name.
     * @returns         A promise containing the loaded module.
     */
    loadScript<TModule>(url: string, options?: ILoadScriptOptions): Promise<TModule>;
    /**
     * Loads a component from a manifest.
     *
     * @param manifest - Manifest of the module to load.
     * @returns          A promise containing the loaded module.
     */
    loadComponent<TComponent>(manifest: IClientSideComponentManifest): Promise<TComponent>;
    /**
     * Resolve a component id and version, and load it.
     *
     * @param id      - The id of the component to load.
     * @param version - The version of the component to load. If version is not defined, the method
     *                    will load any version of the component.
     * @returns         A promise containing the loaded module.
     *
     * @alpha
     */
    loadComponentById<TComponent>(id: string, version?: string): Promise<TComponent>;
    /**
     * Registers manifests in the manifest store.
     *
     * @param manifests - The manifests to register in the store.
     *
     * @alpha
     */
    registerManifests(manifests: IClientSideComponentManifest[]): void;
    /**
     * All registered manifests.
     *
     * @readonly
     * @alpha
     */
    readonly manifests: IClientSideComponentManifest[];
    /**
     * Inserts a <link ... /> tag for a stylesheet.
     *
     * @param url - The CSS file URL.
     */
    loadCss(url: string): void;
    /**
     * If manifests from localhost haven't already been loaded, force them to load without prompting the user.
     *
     * @returns A promise that is fulfilled when the manifests are loaded.
     *
     * @internal
     */
    _forceLocalManifests(): Promise<void>;
    /**
     * Get a component manifest from the component id and version.
     *
     * @param id      - GUID id of the component.
     * @param version - Version of the component. If version is not defined, the method
     *                    will return the manifest for any version of the component.
     * @returns         Manifest for the component.
     *
     * @alpha
     */
    getManifestById(id: string, version?: string): IClientSideComponentManifest;
    private _initialize(preloadedData);
    /**
     * Ensure that a component is set in the system (both SystemJS and the module loader), when it's not
     * loaded by the module loader itself.
     */
    private _setComponent<TComponent>(manifest, componentModule);
    /**
     * Loads all component dependencies for a component.
     * If the dependency can't be found and it has a failover path, it will load it
     * from the path.
     */
    private _loadComponentDependencies(manifest);
    /**
     * Loads all paths dependencies for a component, excluding the entry point.
     * If a path dependency is marked as shouldNotPreload, it is skipped
     */
    private _loadPathDependencies(manifest);
    /**
     * Loads the entry point for a component.
     * It saves the entry point in systemJS under the componentId, and in ComponentStore.
     */
    private _loadEntryPoint<TModule>(manifest);
    private _saveModuleInComponentStore<TModule>(manifest, module);
    /**
     * Returns the export of a module. If the export is not the module itself, it does
     * the fixup on SystemJS
     */
    private _getExportFromModule<TModule>(manifest, module);
    private _loadDebugManifests(noPrompt?, noCache?, alternativeManifestsFiles?, noAlert?);
}
